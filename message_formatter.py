from typing import Dict, List, Tuple
from datetime import datetime, timezone

class MessageFormatter:
    @staticmethod
    def format_holders_table(holders_data: List[Dict]) -> str:
        """Format holders data as a telegram-friendly table with emojis and tags"""
        current_time = datetime.now(timezone.utc)
        analysis_time = datetime.strptime(holders_data[0].get('analysis_time', current_time.strftime('%Y-%m-%d %H:%M:%S')), '%Y-%m-%d %H:%M:%S')
        analysis_time = analysis_time.replace(tzinfo=timezone.utc)
        
        time_diff = current_time - analysis_time
        data_freshness = "üü¢ Real-time" if time_diff.seconds < 300 else "üü° Recent" if time_diff.seconds < 3600 else "üî¥ Delayed"
        
        message = "üìä *Top Holders Analysis*\n"
        message += f"üïí Analysis Time: {analysis_time.strftime('%Y-%m-%d %H:%M:%S')} UTC ({data_freshness})\n\n"
        
        for idx, holder in enumerate(holders_data, 1):
            # Determine holder type and tags
            type_emoji = {
                "Contract": "üìú",
                "Developer": "üë®‚Äçüíª",
                "User": "üë§",
                "Fresh Wallet": "üÜï",
                "Bot": "ü§ñ",
                "Likely Bot": "‚ö†Ô∏è",
                "OG": "üëë",
                "Blackhole": "üî•"
            }.get(holder["address_type"], "üë§")
            
            # Determine tags
            tags = []
            age_days = holder['age_info']['wallet_age_days']
            tx_count = holder['activity_info']['total_recent_tx_count']
            
            if holder['address_type'] == 'Blackhole':
                tags = ["üî• Burn Address"]
            elif holder['address_type'] == 'Developer':
                tags = ["üë®‚Äçüíª Token Developer"]
                if age_days < 30:
                    tags.append("‚ö†Ô∏è New Dev")
                if holder['balance_percentage'] > 20:
                    tags.append("‚ö†Ô∏è High Dev Holdings")
            else:
                if age_days < 7:
                    tags.append("üÜï Fresh Wallet")
                if tx_count > 1500:
                    tags.append("ü§ñ Bot")
                elif tx_count > 750:
                    tags.append("‚ö†Ô∏è Likely Bot")
                elif age_days > 360 and holder['nft_info']['eth_nfts']:
                    tags.append("üëë OG")
                elif holder['address_type'] == 'Contract':
                    tags.append("üìú Contract")
            
            tags_str = " | ".join(tags) if tags else "Normal"
            
            # Determine activity status
            activity = "‚úÖ" if holder["activity_info"]["is_active_overall"] else "‚ùå"
            
            # Format NFT status
            nft_status = []
            if holder["nft_info"]["base_nfts"]:
                nft_status.append("Base‚úÖ")
            if holder["nft_info"]["eth_nfts"]:
                nft_status.append("ETH‚úÖ")
            nft_str = " ".join(nft_status) if nft_status else "‚ùå"
            
            # Update balance formatting to show smaller amounts
            balance = holder['token_balance']
            balance_str = (
                f"{balance:.8f}" if balance < 0.01 else  # Show 8 decimals for very small amounts
                f"{balance:.4f}" if balance < 1 else     # Show 4 decimals for small amounts
                f"{balance:.2f}"                         # Show 2 decimals for larger amounts
            )
            
            # Create holder entry with special formatting for Developer
            if holder['address_type'] == 'Developer':
                entry = (
                    f"{idx}. {type_emoji} `{holder['address'][:6]}...{holder['address'][-4:]}` üë®‚Äçüíª\n"
                    f"   üí∞ Balance: `{balance_str}` ({holder['balance_percentage']:.4f}%)\n"
                    f"   ‚è≥ Age: {holder['age_info']['wallet_age_days']} days\n"
                    f"   üé® NFTs: {nft_str}\n"
                    f"   üìà Activity: {activity} ({tx_count} tx/30d)\n"
                    f"   üè∑Ô∏è Tags: {tags_str}\n"
                    f"   üíº ETH History: {holder['activity_info']['ethereum']['total_tx_display']} tx\n"
                    "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
                )
            else:
                entry = (
                    f"{idx}. {type_emoji} `{holder['address'][:6]}...{holder['address'][-4:]}`\n"
                    f"   üí∞ Balance: `{balance_str}` ({holder['balance_percentage']:.4f}%)\n"
                    f"   ‚è≥ Age: {holder['age_info']['wallet_age_days']} days\n"
                    f"   üé® NFTs: {nft_str}\n"
                    f"   üìà Activity: {activity} ({tx_count} tx/30d)\n"
                    f"   üè∑Ô∏è Tags: {tags_str}\n"
                    "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
                )
            message += entry
        
        return message

    @staticmethod
    def calculate_risk_score(analysis_data: Dict) -> Tuple[int, List[str], str]:
        """Calculate comprehensive risk score analyzing 50 holders"""
        risk_score = 0
        risk_factors = []
        holders = analysis_data['holders_analysis']

        # 1. OG Holder Analysis
        og_holders = sum(1 for h in holders if h['age_info']['wallet_age_days'] > 360 and h['nft_info']['eth_nfts'])
        og_percentage = (og_holders / len(holders)) * 100
        
        # Fix the OG percentage thresholds and messaging
        if og_percentage >= 35:
            risk_score -= 25
            risk_factors.append(f"‚úÖ Strong OG holder base ({og_percentage:.1f}%)")
        elif og_percentage >= 25:
            risk_score -= 15
            risk_factors.append(f"‚úÖ Solid OG holder base ({og_percentage:.1f}%)")
        elif og_percentage >= 10:
            risk_score -= 5
            risk_factors.append(f"‚úÖ Some OG holder presence ({og_percentage:.1f}%)")
        # Remove any OG-related risk factors if percentage is too low
        if og_percentage < 10:
            risk_factors = [f for f in risk_factors if "OG holder" not in f]

        # Check OG presence in top holders
        top_10_ogs = sum(1 for h in holders[:10] 
                        if h['age_info']['wallet_age_days'] > 360 
                        and h['nft_info']['eth_nfts'])
        if top_10_ogs >= 6:
            risk_score -= 15
            risk_factors.append("‚úÖ Strong OG presence in top holders")

        # 2. Concentration Risk Analysis
        top_holder_percent = holders[0]['balance_percentage']
        top_5_holders_percent = sum(h['balance_percentage'] for h in holders[:5])
        top_10_holders_percent = sum(h['balance_percentage'] for h in holders[:10])
        
        # Single wallet concentration
        if top_holder_percent > 50:
            risk_score += 30
            risk_factors.append("‚ùå Critical: Single wallet holds >50% supply")
        elif top_holder_percent > 30:
            risk_score += 20
            risk_factors.append("‚ö†Ô∏è High: Single wallet holds >30% supply")
        elif top_holder_percent > 15:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è Moderate: Single wallet holds >15% supply")

        # Group concentration
        if top_5_holders_percent > 80:
            risk_score += 15
            risk_factors.append("‚ùå Top 5 wallets control >80% supply")
        if top_10_holders_percent > 90:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è Top 10 wallets control >90% supply")

        # 3. Holder Age Analysis
        fresh_wallets = sum(1 for h in holders if h['age_info']['wallet_age_days'] < 7)
        new_wallets = sum(1 for h in holders if h['age_info']['wallet_age_days'] < 30)
        top_10_fresh = sum(1 for h in holders[:10] if h['age_info']['wallet_age_days'] < 7)
        
        if fresh_wallets >= 8:
            risk_score += 15
            risk_factors.append("üÜï High number of fresh wallets (<7 days)")
        elif fresh_wallets >= 5:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è Notable number of fresh wallets (<7 days)")
        
        if new_wallets >= 8:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è High concentration of new wallets (<30 days)")
        
        if top_10_fresh > 2:
            risk_score += 15
            risk_factors.append("‚ùå Multiple top 10 holders are fresh wallets")

        # 4. Bot Activity Analysis
        bot_wallets = sum(1 for h in holders if h['activity_info']['total_recent_tx_count'] > 9999)
        likely_bot_wallets = sum(1 for h in holders if 1000 < h['activity_info']['total_recent_tx_count'] <= 9999)
        
        if likely_bot_wallets >= 8:
            risk_score += 15
            risk_factors.append("‚ö†Ô∏è High number of likely bot wallets detected")
        elif likely_bot_wallets >= 5:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è Notable number of likely bot wallets detected")
        
        if bot_wallets >= 5:
            risk_score += 15
            risk_factors.append("ü§ñ High number of bot wallets detected")

        # 5. Wallet Pattern Analysis
        similar_age_pattern = 0
        for i in range(len(holders) - 1):
            if abs(holders[i]['age_info']['wallet_age_days'] - holders[i+1]['age_info']['wallet_age_days']) < 2:
                similar_age_pattern += 1
        
        if similar_age_pattern > 10:
            risk_score += 15
            risk_factors.append("‚ö†Ô∏è Suspicious pattern: Multiple wallets created at similar times")

        # 6. Cross-chain Activity
        low_eth_activity = sum(1 for h in holders[:20] 
                            if h['activity_info']['ethereum']['total_tx_count'] < 10 
                            and h['balance_percentage'] > 2)
        
        if low_eth_activity > 10:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è Many large holders have limited Ethereum activity")

        # 7. Developer Analysis
        if analysis_data.get('deployer_analysis'):
            dev = analysis_data['deployer_analysis']
            
            # Age checks
            if dev['age_info']['wallet_age_days'] < 30:
                risk_score += 15
                risk_factors.append("üë®‚Äçüíª Developer wallet is new (<30 days)")
            
            # Activity checks
            if not dev['activity_info']['ethereum']['total_tx_count']:
                risk_score += 10
                risk_factors.append("‚ö†Ô∏è Developer has no Ethereum history")
            
            # Balance checks
            if dev['balance_percentage'] > 20:
                risk_score += 15
                risk_factors.append("‚ö†Ô∏è Developer holds significant supply (>20%)")
            
            # Sophistication check
            if not (dev['nft_info']['eth_nfts'] or dev['nft_info']['base_nfts']) and \
            dev['activity_info']['ethereum']['total_tx_count'] < 50:
                risk_score += 10
                risk_factors.append("‚ö†Ô∏è Developer shows limited blockchain experience")

        # 8. Contract Holder Analysis
        contract_holders = sum(1 for h in holders if h['address_type'] == 'Contract')
        large_contract_holders = sum(1 for h in holders 
                                if h['address_type'] == 'Contract' 
                                and h['balance_percentage'] > 5)
        
        if large_contract_holders > 3:
            risk_score += 15
            risk_factors.append("‚ö†Ô∏è Multiple large contract holders detected")
        elif contract_holders > 10:
            risk_score += 10
            risk_factors.append("‚ÑπÔ∏è High number of contract holders")

        # 9. Activity Distribution
        inactive_large_holders = sum(1 for h in holders[:20] 
                                if not h['activity_info']['is_active_overall'] 
                                and h['balance_percentage'] > 2)
        
        if inactive_large_holders > 5:
            risk_score += 10
            risk_factors.append("‚ö†Ô∏è Multiple large holders are inactive")

        # Ensure risk score stays within bounds
        risk_score = max(0, min(risk_score, 100))

        # Determine risk level
        if risk_score >= 75:
            risk_level = "üî¥ Very High Risk"
        elif risk_score >= 50:
            risk_level = "üü† High Risk"
        elif risk_score >= 30:
            risk_level = "üü° Medium Risk"
        elif risk_score >= 15:
            risk_level = "üü¢ Low Risk"
        else:
            risk_level = "‚úÖ Very Low Risk"

        return risk_score, risk_factors, risk_level

    @staticmethod
    def format_analysis_summary(summary_stats: Dict, analysis_data: Dict) -> str:
        """Format analysis summary with risk score"""
        risk_score, risk_factors, risk_level = MessageFormatter.calculate_risk_score(analysis_data)
        
        message = (
            "üìä *Token Analysis Summary*\n"
            f"üïí Analysis Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC\n\n"
            f"üë• Total Wallets: {summary_stats['Total Wallets Analyzed']}\n"
            f"üíπ Supply Coverage: {summary_stats['Total Supply Coverage']}\n"
            f"‚è≥ Average Wallet Age: {summary_stats['Average Wallet Age']:.1f} days\n\n"
            "*Holder Categories:*\n"
        )
        
        for category, count in summary_stats['Category Distribution'].items():
            if category:
                emoji = {
                    "Contract": "üìú",
                    "Fresh Wallet": "üÜï",
                    "Bot": "ü§ñ",
                    "Likely Bot": "‚ö†Ô∏è",
                    "OG": "üëë",
                }.get(category, "üë§")
                percentage = (count / summary_stats['Total Wallets Analyzed']) * 100
                message += f"{emoji} {category}: {count} ({percentage:.1f}%)\n"
        
        message += f"\nüéØ *Risk Assessment*\n"
        message += f"Risk Level: {risk_level}\n"
        message += f"Risk Score: {risk_score}/100\n\n"
        
        if risk_factors:
            message += "*Risk Factors:*\n"
            message += "\n".join(risk_factors)
        else:
            message += "‚úÖ No major risk factors detected"
        
        return message

    def format_connection_analysis(self, connection_data: Dict) -> str:
        """Format wallet connection analysis results with improved risk assessment"""
        try:
            if not connection_data:
                return "‚ùå No connection analysis data available"

            # Initialize base risk metrics with higher weights
            cluster_risk = 0
            creation_risk = 0
            
            # Calculate cluster-based risk with increased sensitivity
            if connection_data['risk_score']['num_clusters'] > 3:  # Lowered threshold
                cluster_risk = 4  # Increased risk score
            elif connection_data['risk_score']['num_clusters'] > 2:
                cluster_risk = 3
            elif connection_data['risk_score']['num_clusters'] > 1:
                cluster_risk = 2
                
            # Increased risk for connected wallets
            if connection_data['risk_score']['largest_cluster_size'] > 5:
                cluster_risk += 4
            elif connection_data['risk_score']['largest_cluster_size'] > 3:
                cluster_risk += 3
            elif connection_data['risk_score']['largest_cluster_size'] > 1:
                cluster_risk += 2
                
            # More sensitive network density thresholds
            if connection_data['risk_score']['network_density'] > 0.05:
                cluster_risk += 4
            elif connection_data['risk_score']['network_density'] > 0.01:
                cluster_risk += 3
            elif connection_data['risk_score']['network_density'] > 0.005:
                cluster_risk += 2

            # Calculate creation pattern risk with higher penalties
            if connection_data.get('creation_patterns'):
                num_patterns = len(connection_data['creation_patterns'])
                time_diffs = [p.get('time_difference', 24) for p in connection_data['creation_patterns']]
                avg_time_diff = sum(time_diffs) / len(time_diffs) if time_diffs else 24
                
                # Increased risk for multiple patterns
                if num_patterns > 5:
                    creation_risk += 5
                elif num_patterns > 3:
                    creation_risk += 4
                elif num_patterns > 1:
                    creation_risk += 3
                    
                # More aggressive risk for close creation times
                if avg_time_diff < 0.5:  # Less than 30 minutes apart
                    creation_risk += 5
                elif avg_time_diff < 2:  # Less than 2 hours apart
                    creation_risk += 4
                elif avg_time_diff < 6:  # Less than 6 hours apart
                    creation_risk += 3

            # Calculate total risk with adjusted thresholds
            total_risk = cluster_risk + creation_risk
            
            if total_risk >= 6:  # Lowered threshold for high risk
                risk_level = "üî¥ High Risk"
                risk_score = 85 + min(15, (total_risk - 6) * 3)
            elif total_risk >= 4:
                risk_level = "üü† Moderate Risk"
                risk_score = 65 + ((total_risk - 4) * 10)
            elif total_risk >= 2:
                risk_level = "üü° Medium Risk"
                risk_score = 45 + ((total_risk - 2) * 10)
            else:
                risk_level = "üü¢ Low Risk"
                risk_score = max(20, total_risk * 20)

            message = (
                "üîó *Wallet Connection Analysis*\n\n"
                "üìä *Network Statistics*\n"
                f"‚Ä¢ Connected Groups: {connection_data['risk_score']['num_clusters']}\n"
                f"‚Ä¢ Wallets per Group: {connection_data['risk_score']['largest_cluster_size']}\n"
                f"‚Ä¢ Network Density: {connection_data['risk_score']['network_density']:.3f}\n"
            )

            # Add creation pattern summary if exists
            if connection_data.get('creation_patterns'):
                message += f" Suspicious Creation Patterns: {len(connection_data['creation_patterns'])}\n"
                if time_diffs:
                    message += f"‚Ä¢ Average Creation Time Gap: {avg_time_diff:.1f} hours\n"

            message += (
                f"\nüéØ *Risk Assessment*\n"
                f"‚Ä¢ Risk Level: {risk_level}\n"
                f"‚Ä¢ Risk Score: {risk_score:.1f}/100\n"
            )

            # Add creation patterns if exist
            if connection_data.get('creation_patterns'):
                message += "\n*‚è∞ Creation Time Patterns*\n"
                # Filter patterns for <= 30 minutes
                close_patterns = [p for p in connection_data['creation_patterns'] 
                                 if p.get('time_difference', float('inf')) <= 30]
                
                for pattern in close_patterns[:5]:
                    addr1, addr2 = pattern['wallets']
                    minutes = pattern.get('time_difference', 0)
                    
                    # Format time string more precisely
                    if minutes < 1:
                        seconds = int(minutes * 60)
                        time_str = f"{seconds} seconds"
                    elif minutes < 2:
                        time_str = "1 minute"
                    else:
                        time_str = f"{int(minutes)} minutes"
                    
                    message += (
                        f"‚Ä¢ `{addr1[:6]}...{addr1[-4:]}` ‚ÜîÔ∏è "
                        f"`{addr2[:6]}...{addr2[-4:]}`\n"
                        f"  Created within {time_str}\n"
                    )
                    
                remaining = len(close_patterns) - 5
                if remaining > 0:
                    message += f"_...and {remaining} more patterns within 30 minutes_\n"

            # Add clusters/groups
            if connection_data.get('clusters'):
                message += "\n*üë• Connected Wallet Groups*\n"
                for idx, cluster in enumerate(connection_data['clusters'], 1):
                    if len(cluster) > 1:
                        message += (
                            f"\n*Group #{idx}* ({len(cluster)} wallets)\n"
                            "‚Ä¢ Addresses: "
                        )
                        # Show first few addresses
                        for addr in cluster[:3]:
                            message += f"`{addr[:6]}...{addr[-4:]}` "
                        if len(cluster) > 3:
                            message += f"\n  _...and {len(cluster) - 3} more_"

            return message

        except Exception as e:
            logger.error(f"Error formatting connection analysis: {str(e)}")
            return "‚ùå Error formatting wallet connection analysis."

    @staticmethod
    def format_developer_info(dev_data: Dict) -> str:
        """Format developer information with emojis"""
        template = (
            "üë®‚Äçüíª *Developer Analysis*\n"
            f"üïí Analysis Time: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC\n\n"
            f"üìç Address: `{dev_data['address']}`\n"
            f"üíº Type: {dev_data['address_type']}\n"
            f"üí∞ Token Holdings: `{dev_data['token_balance']:.4f}`\n"
            f"üìä Share: `{dev_data['balance_percentage']:.2f}%`\n\n"
            "üîê *Security Metrics*\n"
            f"üìÖ Account Age: {dev_data['age_info']['wallet_age_days']} days\n"
            f"üåê Multi-chain: {'‚úÖ' if dev_data['activity_info']['ethereum']['total_tx_count'] > 0 else '‚ùå'}\n"
            f"üé® Has NFTs: {'‚úÖ' if dev_data['nft_info']['eth_nfts'] or dev_data['nft_info']['base_nfts'] else '‚ùå'}\n\n"
            "üìà *Activity Overview*\n"
            f"Base Transactions: {dev_data['activity_info']['base_chain']['total_tx_display']}\n"
            f"ETH Transactions: {dev_data['activity_info']['ethereum']['total_tx_display']}\n"
            f"Recent Activity: {dev_data['activity_info']['total_recent_tx_count']} tx (30d)"
        )
        return template